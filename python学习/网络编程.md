[TOC]

# 网络编程(2022.2.12)

***在cmd中输入ipconfig可以看到自己的IP设置***（macos可以ifconfig）

## C/S架构和B/S架构

Client(客户端)<==============>Server(服务器)

腾讯作为服务端为你提供视频，你得下个腾讯视频客户端才能看它的视频

Browser(浏览器)<============>Server(服务器)

## 网络通信

### 网络存在的意义就是跨地域数据传输称为网络通信

### 网络=物理链接介质+互联网通信协议

物理链接介质(路由器，防火墙，网线)，(没有必要学习,这个是网络工程师学的)

## 互联网通信协议

互联网协议就相当是计算机的"英语"，所有计算机都是靠互联网协议来沟通的。

英语成为世界上所有人通信的统一标准，如果把计算机看成分布于世界各地的人，那么连接两台计算机之间的internet实际上就是

一系列统一的标准，这些标准称之为互联网协议，互联网的本质就是一系列的协议，总称为‘互联网协议’（Internet Protocol Suite).

互联网协议的功能：定义计算机如何接入internet，以及接入internet的计算机通信的标准。

## osi七层协议

![](https://s2.loli.net/2022/02/12/SMGLDRKqT3uvgyz.jpg)

顺口溜(应表会传网数物)   

**七层**划分为：**应用层、表示层、会话层、传输层、网络层、数据链路层、物理层**。

**五层**划分为：**应用层、传输层、网络层、数据链路层、物理层**。

**四层**划分为：**应用层、传输层、网络层、网络接口层**。



![](https://s2.loli.net/2022/02/12/iYIaW3l5JVhMOyc.gif)

**最后的包的构成是由>>>>>>ethernet头+ip头+tcp头+应用层的头+应用层数据**

协议：规定数据的组织格式

​			格式：头部+数据部分

发送数据就好似打包东西，打包就是数据外加头，拆包就是卸掉头获取数据。(包的头部会可能很多。)

## 1.物理层

物理层功能：主要是基于电器特性发送高低电压(电信号)，高电压对应数字1，低电压对应数字0。

一组物理层数据称之为"位"

## 2.数据链路层

数据链路层由来：单纯的电信号0和1没有任何意义，必须规定电信号多少位一组，每组什么意思

数据链路层的功能：定义了电信号的分组方式

### 2.1以太网协议ethernet：

规定1：一组数据链路层称为"帧"，数据帧

规定2：数据帧包括两部分：头+数据

​				头包含：源地址和目标地址，该地址是mac地址

​				数据的内容包含的是网络层整体的内容。

规定3：规定但凡接入互联网的主机必须必须有一块网卡，每块网卡出厂前都烧制了一个全世界第一无				二的地址，该地址就是mac地址。 (相当于计算机的身份证号)

### 2.2mac地址：

​		mac地址：每块网卡出厂时都被烧制上一个世界唯一的mac地址，长度为48位2进制，通常由12位16进制数表示（前六位是厂商编号，后六位是流水线号）

### 2.3广播：

​		广播是一中传播的方式。(以太网工作的方式是广播)

​		将数据打包后发给所有的计算机，所有的计算机开始拆包，拆包后发现目标mac地址如如果是自己的，就留下，如果不是就丢弃。

​			有了mac地址，同一网络内的两台主机就可以通信了（一台主机通过arp协议获取另外一台主机的mac地址）ethernet采用最原始的方式，广播的方式进行通信，即计算机通信基本靠吼

## 3.网络层

网络层由来：有了ethernet、mac地址、广播的发送方式，世界上的计算机就可以彼此通信了，问题是世界范围的互联网是由一个个彼此隔离的小的局域网组成的，那么如果所有的通信都采用以太网的广播方式，那么一台机器发送的包全世界都会收到，这就不仅仅是效率低的问题了，这会是一种灾难

网络层功能：引入一套新的地址用来区分不同的广播域／子网，这套地址即网络地址,(划分网络域)

规定1：一个数据是一个数据包

规定2：数据帧包括两部分：头+数据

​			  头包含：源地址和目标地址，该地址是IP地址

​			  数据包含:传输层整体的内容。

### 3.1ip协议

规定网络地址的协议叫ip协议，它定义的地址称之为ip地址，广泛采用的v4版本即ipv4，它规定网络地址由32位2进制表示

范围0.0.0.0-255.255.255.255

一个ip地址通常写成四段十进制数，例：172.16.10.1

例：172.16.10.1与172.16.10.2并不能确定二者处于同一子网

ip地址分成两部分

网络部分：标识子网

主机部分：标识主机

### 3.2子网掩码

所谓”子网掩码”，就是表示子网络特征的一个参数。

它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.10.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。

知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。

**总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。**

### 3.3ARP协议

必须在ARP协议下将ip地址转换成mac地址

arp协议功能：广播的方式发送数据包，获取目标主机的mac地址

协议工作方式：每台主机ip都是已知的

**总结：IP地址+mac地址>>>>>可以标识全世界独一无二的一台计算机。**

## 4.传输层 

tcp\udp     基于端口

我们通过ip和mac找到了一台特定的主机，如何标识这台主机上的应用程序，答案就是端口，端口即应用程序与网卡关联的编号。

传输层功能：建立端口到端口的通信

端口范围0-65535，0-1023为系统占用接口。

**IP+port(端口)>>>>>可以标识全世界独一无二的一个基于网络通信的应用程序。**

### 4.1tcp协议：

基于tcp协议通信之前：必须建立一个双向通信的链接。

C----------------------------------------->>S

B<<-----------------------------------------S

通过三次握手建立链接。

​		因为建立链接是为了传输数据做准备，三次握手即可。

通过四次握手断开链接。

​		断开链接是，由于链接内有数据传输，所以必须反四次断开。

![1036857-20161008185648160-191189690](https://s2.loli.net/2022/02/13/dX4scL39BJfi2lr.jpg)

​												**tcp三个握手和四次挥手图(重要)**

### 4.2tcp是可靠传输的

tcp安全的原因是，客户端发送数据后，服务端收到数据后并返回一个消息，返回给客户端。

发送数据后必须必须等对方确定后才算完成，才会将自己的内存清理。

**当服务器大量处于TIME_WAIT状态时意味着服务端正在经历高并发。**

### 4.3udp不可靠传输



### 4.4tcp协议下的半连接池

backlog

[链接请求1，链接请求2，链接请求3，链接请求4]

防止服务器奔溃，想请求的，一个一个来

## 5.应用层

可以自定义协议>>>>头部+数据部分

### 				1自定义协议需要注意的问题:

​				1.两大组成部分=头部和诗句部分

​							头部：放对数据的描述信息，

​										比如：数据要发给谁，数据的类型，数据的长度

​							数据部分：想要发的数据

​					2.头部的长度必须固定。

​								因为接受端要通过头部获取所接受数据的详细信息。

​						http,https,ftp.			

## 6. socket

### 6.1 什么时socket

​		**Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。**

在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。

所以，我们无需深入理解tcp/udp协议，socket已经为我们封装好了，我们只需要遵循socket的规定去编程，写出的程序自然就是遵循tcp/udp标准的

`也有人将socket说成ip+port，ip是用来标识互联网中的一台主机的位置，而port是用来标识这台机器上的一个应用程序，ip地址是配置到网卡上的，而port是应用程序开启的，ip与port的绑定就标识了互联网中独一无二的一个应用程序`

![v2-7d4ff6c59a5201bac25926b792826a40_1440w](https://s2.loli.net/2022/02/14/EuXvjtQJigwSONA.jpg)

#### 6.2 socket常用的命令

##### **基于文件类型的套接字家族**

套接字家族的名字：AF_UNIX

unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信

##### **基于网络类型的套接字家族**

套接字家族的名字：AF_INET

(还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET)

```python
 5 #获取tcp/ip套接字
 6 tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
 7 
 8 #获取udp/ip套接字
 9 udpSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
```

##### 1.服务端套接字函数

s.bind() 绑定(主机,端口号)到套接字
s.listen() 开始TCP监听
s.accept() 被动接受TCP客户的连接,(阻塞式)等待连接的到来

##### 2.客户端套接字函数

s.connect() 主动初始化TCP服务器连接
s.connect_ex() connect()函数的扩展版本,出错时返回出错码,而不是抛出异常

##### 3.公共用途的套接字函数

s.recv() 接收TCP数据
s.send() 发送TCP数据(send在待发送数据量大于己端缓存区剩余空间时,数据丢失,不会发完)
s.sendall() 发送完整的TCP数据(本质就是循环调用send,sendall在待发送数据量大于己端缓存区剩余空间时,数据不丢失,循环调用send直到发完)
s.recvfrom() 接收UDP数据
s.sendto() 发送UDP数据
s.getpeername() 连接到当前套接字的远端的地址
s.getsockname() 当前套接字的地址
s.getsockopt() 返回指定套接字的参数
s.setsockopt() 设置指定套接字的参数
s.close() 关闭套接字

##### 4.面向锁的套接字方法

s.setblocking() 设置套接字的阻塞与非阻塞模式
s.settimeout() 设置阻塞套接字操作的超时时间
s.gettimeout() 得到阻塞套接字操作的超时时间

##### 5.面向文件的套接字的函数

s.fileno() 套接字的文件描述符
s.makefile() 创建一个与该套接字相关的文件

**tcp是基于链接的，必须先启动服务端，然后再启动客户端去链接服务端**

### tcp服务端

```python
ss = socket() #创建服务器套接字
ss.bind()      #把地址绑定到套接字
ss.listen()      #监听链接
inf_loop:      #服务器无限循环
    cs = ss.accept() #接受客户端链接
    comm_loop:         #通讯循环
    	cs.recv()/cs.send() #对话(接收与发送)
	cs.close()    #关闭客户端套接字
ss.close()        #关闭服务器套接字(可选)
```

### tcp客户端

```python
cs = socket()    # 创建客户套接字
cs.connect()    # 尝试连接服务器
comm_loop:        # 通讯循环
    cs.send()/cs.recv()    # 对话(发送/接收)
cs.close()            # 关闭客户套接字
```

### 粘包问题

#### 1. 粘包问题出现的原因

1.tcp是流式协议，数据像水流一样粘在了一起，没有任何界面之分。

2.收数据没有收干净，有残留，就会和下一次结果出现混淆。

**struct模块**

该模块可以把一个类型，如数字，转成固定长度的bytes![img](https://s2.loli.net/2022/02/18/ExZdv4bqDycFl8j.jpg)
